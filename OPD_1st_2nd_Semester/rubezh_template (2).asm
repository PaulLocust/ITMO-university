ORG 0x10

arrayLength:     WORD ?               ; Длина массива
arrayAddress:    WORD ?               ; Адрес массива
curAddress:      WORD ?               ; Адрес текущего элемента массива
curIndex:        WORD 0x0000          ; Индекс текущего элемента массива
curHead:         WORD ?               ; Адрес первого слова элемента массива
curTail:         WORD ?               ; Адрес последнего слова элемента массива
signBitMask:     WORD ?               ; Маска для проверки знака числа
positiveNumMask: WORD ?               ; Маска для расширения положительного числа
negativeNumMask: WORD ?               ; Маска для расширения отрицательного числа 
resHead:         WORD ?               ; Адрес первого слова результата
resTail:         WORD ?               ; Адрес последнего слова результата

step:            WORD 0x0003          ; Шаг для перехода к следующему элементу массива

FINISH:          HLT                  ; Останов

; Подпрограмма для расширения знака
EXTEND_SIGN:     LD &1                  ; Получение аргумента
                 AND $signBitMask       ; Проверка знака, если число положительное, то Z = 1
                 BEQ POSITIVE           ; Если число положительное, то переход к расширению положительного числа
NEGATIVE:        LD &1                  ; Получение аргумента
                 OR $negativeNumMask    ; Расширение отрицательного числа
                 JUMP EXT_SIGN_RET 
POSITIVE:        LD &1                  ; Получение аргумента
                 AND $positiveNumMask   ; Расширение положительного числа
EXT_SIGN_RET:    ST &1                  ; Сохранение результата
                 RET

START:           LD arrayAddress        ; Загрузка адреса массива
                 ST $curAddress         ; Сохранение адреса текущего элемента массива
                 CLA                    ; Очистка аккумулятора
                 ST $curIndex           ; Обнуление индекса текущего элемента массива
                 ST $resHead            ; Обнуление адреса первого слова результата
                 ST $resTail            ; Обнуление адреса последнего слова результата
SPIN_0:          IN 5                   ; Спин-луп для ввода шага
                 AND #0x40
                 BEQ SPIN_0
                 IN 4
                 ST $step               ; Сохранение шага для перехода к следующему элементу массива

MAINLOOP:        LD arrayAddress
                 ADD $curIndex          ; Переход к текущему элементу массива
                 ST $curAddress         ; Сохранение адреса текущего элемента массива

                 LD (curAddress)+       ; Загрузка адреса текущего элемента массива и инкремент
                 ST $curHead            ; Сохранение адреса первого слова элемента массива
                 LD curAddress          ; Загрузка адреса текущего элемента массива
                 ST $curTail            ; Сохранение адреса последнего слова элемента массива
                 
                 LD $curHead
                 PUSH                   ; Пушим адрес первого слова элемента массива
                 CALL EXTEND_SIGN       ; Расширяем знак
                 POP                    ; Попим адрес первого слова элемента массива
                 ST $curHead            ; Сохранение адреса первого слова элемента массива
                 
MAINLOGIC:       LD $resTail
                 ADD $curTail
                 ST $resTail            ; Обновление адреса последнего слова результата
                 LD $resHead            ; Загрузка адреса первого слова результата (Carry flag установлен)
                 ADC $curHead           ; Сложение первых слов
                 ST $resHead            ; Сохранение адреса первого слова результата

                 LD $curIndex           ; Загрузка индекса текущего элемента массива
                 ADD $step              ; Переход к следующему элементу массива
                 ST $curIndex           ; Сохранение индекса текущего элемента массива

                 CMP $arrayLength       ; Сравнение индекса текущего элемента массива с длиной массива
                 BLT MAINLOOP           ; Если индекс текущего элемента массива меньше длины массива, то переход к следующему элементу массива
                 JUMP FINISH            ; Иначе завершение программы
