	ORG	0x100

TT1:	WORD	0x0	; Результат теста №1. Проверка корректного результата сдвига вправо и зануления 15 бита
TT2:	WORD	0x0	; Результат теста №2. Проверка на отсутствие изменения признаков результата

MASK:	WORD	0xFFFE	; Маска для зануления 0 бита слова
	
	ORG	0x200
START:	CLA		; Начало программы
	CALL 	$TEST1	; Вызов первого теста
	LD	$TT1	; Загрузка результата 1-го теста
	HLT		; NOP Метка для проверки
	CLC
	CALL	$TEST2
	LD	$TT2
	HLT		; Метка для проверки
	

	ORG	0x300
A1:	WORD	0xFFFF	; Тестовое слово
RES1:	WORD ?		; Результат 'ручного' преобразования
TEST1:	LD	A1	; Загружаем A1
	AND	$MASK	; Используем маску, чтобы обнулить 0-й бит
	ROR		; Циклический сдвиг вправо, так как 0-й бит = 0, то в 15 пойдёт 0, как и задумывалось
	ST	$RES1	; Сохраняем результат 'ручного' преобразования
	WORD	0x9300	; Вызываем нашу адресную команду по адресу A1
	LD	A1	; Загружаем изменённое командой значение A1 в AC
	CMP	RES1	; Сравниваем AC и RES1
	BNE	ERR1	; Если они не равны, то прыгаем в ошибку ERR1
CORR1:	LD	#0x1	; Если нет, то загружаем в TT1 единицу
	ST	$TT1
	RET
ERR1:	LD	#0x0	; Если мы в ошибке, то записать в TT1 ноль
	ST	$TT1
	RET
	
	ORG 	0x350
A2:	WORD 	0xFFFF	; Переменная для проверки флагов	
TEST2:	LD A2		; Загружаем A2
	;PUSHF		; Кладём на стек состояние PS до применение команды
	WORD	0x9350	; Применяем команду на переменную A2
	;PUSHF		; Кладём на стек состояние PS после применение команды
	NOP		; Нужно проверить равенство ячеек стека 7FE и 7FD	
	BCS ERR2
CORR2:	LD	#0x1
	ST	$TT2
	RET
ERR2:	LD	#0x0
	ST	$TT2
	RET
