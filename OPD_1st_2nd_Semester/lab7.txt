	ORG	0x100

TT1:	WORD	0x0	; Результат теста №1. Проверка корректного результата при C = 0
TT2:	WORD	0x0	; Результат теста №2. Проверка на отсутствие изменения признаков результата

WORD	0xF1A6		; Прослойка, чтобы удобнее смотреть флаги
AN2:	WORD 	0x0
AZ2:	WORD 	0x0
AV2:	WORD	0x0
AC2:	WORD	0x0
WORD	0xF1A6		; Прослойка, чтобы удобнее смотреть флаги
RN2:	WORD 	0x0
RZ2:	WORD 	0x0
RV2:	WORD	0x0
RC2:	WORD	0x0
WORD	0xF1A6		; Прослойка, чтобы удобнее смотреть флаги

TT3:	WORD	0x0	; Результат теста №1. Проверка корректного результата при C = 1
MASK:	WORD	0xFFFE
	
	ORG	0x200
START:	CLA		; Начало программы
	CALL 	$TEST1	; Вызов первого теста
	LD	$TT1	; Загрузка результата 1-го теста
	NOP		; Метка для проверки
	CLC
	CALL	$TEST2
	LD	$TT2
	HLT
	

	ORG	0x300
A1:	WORD	0xFFFF
RES1:	WORD ?
TEST1:	LD	A1
	AND	$MASK	
	ROR
	ST	$RES1
	WORD	0x9300
	LD	A1
	CMP	RES1
	BNE	ERR1
CORR1:	LD	#0x1
	ST	$TT1
	RET
ERR1:	LD	#0x0
	ST	$TT1
	ORG	0x100

TT1:	WORD	0x0	; Результат теста №1. Проверка корректного результата при C = 0
TT2:	WORD	0x0	; Результат теста №2. Проверка на отсутствие изменения признаков результата

MASK:	WORD	0xFFFE	; Маска для зануления 0 бита слова
	
	ORG	0x200
START:	CLA		; Начало программы
	CALL 	$TEST1	; Вызов первого теста
	LD	$TT1	; Загрузка результата 1-го теста
	NOP		; Метка для проверки
	CLC
	CALL	$TEST2
	LD	$TT2
	HLT
	

	ORG	0x300
A1:	WORD	0xFFFF	; Тестовое слово
RES1:	WORD ?		; Результат 'ручного' преобразования
TEST1:	LD	A1	; Загружаем A1
	AND	$MASK	; Используем маску, чтобы обнулить 0-й бит
	ROR		; Циклический сдвиг вправо, так как 0-й бит = 0, то в 15 пойдёт 0, как и задумывалось
	ST	$RES1	; Сохраняем результат 'ручного' преобразования
	WORD	0x9300	; Вызываем нашу адресную команду по адресу A1
	LD	A1	; Загружаем изменённое командой значение A1 в AC
	CMP	RES1	; Сравниваем AC и RES1
	BNE	ERR1	; Если они не равны, то прыгаем в ошибку ERR1
CORR1:	LD	#0x1	; Если нет, то загружаем в TT1 единицу
	ST	$TT1
	RET
ERR1:	LD	#0x0	; Если мы в ошибке, то записать в TT1 ноль
	ST	$TT1
	RET
	
	ORG 	0x350 ;   0000 0011 0101 0000
A2:	WORD 0xFFFF
RES2:	WORD ?
TEST2:	LD A2	;NZVC
	;PUSHF		; Кладём на стек состояние PS до применение команды
	WORD	0x9350
	;PUSHF		; Кладём на стек состояние PS после применение команды
	LD RES2	
	BCS	ERR2
CORR2:	LD	#0x1
	ST	$TT2
	RET
ERR2:	LD	#0x0
	ST	$TT2
	RET


44 0010C09001   LD              DR ? AC, N, Z, V

E5 80E2810001                   if DR(0) = 0 then GOTO E2
E6 0010009110                   AC + ~0 ? AC
E9 0010180010                   ROR(AC) ? AC
E6 8053101040                   GOTO ST @ 53
EA 80C4101040                   GOTO INT @ C4 

/////////////E4 0010180010                   ROR(AC) ? AC
/////////////84 0000200000   CLC             0 ? C

E0 0010009001                   DR ? AC
E1 80E3810010                   if AC(0) = 0 then GOTO E3
E2 0010009110                   AC + ~0 ? AC
E3 0001180010                   ROR(AC) ? DR
E4 0200000000                   DR ? MEM(AR)
E5 80C4101040                   GOTO INT @ C4
/////////////
работало
E0 80E2810001   RESERVED        if DR(0) = 0 then GOTO E2
E1 0001009201                   ~0 + DR ? DR
E2 0001180001                   ROR(DR) ? DR
E3 0200000000                   DR ? MEM(AR)
E4 80C4101040                   GOTO INT @ C4


E0 81E5011040   RESERVED        if PS(C) = 1 then GOTO E5
E1 0001180001                   ROR(DR) ? DR
E2 0000200000                   0 ? C
E3 0200000000                   DR ? MEM(AR)
E4 80E9101040                   GOTO E9
E5 0000200000                   0 ? C
E6 0001180001                   ROR(DR) ? DR
E7 0000208300                   HTOH(~0 + ~0) ? C
E8 0200000000                   DR ? MEM(AR)
E9 80C4101040                   GOTO INT @ C4